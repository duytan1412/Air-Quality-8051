Sau khi phân tích toàn bộ source code bạn vừa gửi (bao gồm \`main.c\`, \`delay.c\`, \`watchdog.c\`, \`gp2y1014.c\`, \`mq2.c\`, \`ads1115.c\`...), tôi có nhận xét như sau: \*\*1. TÌNH TRẠNG CÁC "ĐIỂM HỞ" CŨ:\*\* \* \*\*Watchdog vs Delay:\*\* \*\*ĐÃ FIX.\*\* File \`delay.c\` đã include \`watchdog.h\` và gọi \`WDT\_Feed()\` trong vòng lặp. Rất tốt. \* \*\*Nút nhấn không nhạy:\*\* \*\*ĐÃ FIX.\*\* File \`main.c\` đã sử dụng Ngắt ngoài \`INT0\_ISR\` để bắt sự kiện nhấn nút. Nút nhấn sẽ phản hồi ngay lập tức. \* \*\*Công thức Gas:\*\* \*\*ĐÃ FIX.\*\* Đã thêm \`MQ2\_ZERO\_THRESHOLD\` để trừ nhiễu nền. Tuy nhiên, tôi đã phát hiện ra \*\*2 ĐIỂM CHẾT MỚI (FATAL FLAWS)\*\* cực kỳ nghiêm trọng liên quan đến cách sử dụng ADC ADS1115. Đây là lỗi về \*\*Kiến trúc driver\*\* và \*\*Xung đột tài nguyên\*\*, nếu giám khảo phát hiện ra thì hệ thống coi như "chết lâm sàng". ----- ### ĐIỂM CHẾT 1: XUNG ĐỘT KÊNH ADC (MUX CONFLICT) \*\*Mức độ:\*\* Nghiêm trọng (Dữ liệu sai hoàn toàn). \*\*Phân tích:\*\* 1. \*\*Khởi tạo:\*\* Trong \`GP2Y1014\_Init()\`, bạn gọi \`ADS1115\_StartContinuous(1)\`. Lúc này ADC cấu hình đọc liên tục \*\*Kênh 1\*\*. 2. \*\*Vòng lặp chạy:\*\* \* Đến lượt đọc \*\*MQ2\*\* (Gas): Hàm \`MQ2\_Read\` gọi \`ADS1115\_ReadChannel(0)\`. Hàm này ghi vào thanh ghi Config để chuyển sang chế độ Single-shot và \*\*chuyển sang Kênh 0\*\*. \* Đến lượt đọc \*\*Bụi\*\* (GP2Y): Hàm \`GP2Y1014\_Read\` gọi \`ADS1115\_ReadContinuous()\`. Hãy nhìn kỹ hàm này trong \`ads1115.c\`: \*\*Nó chỉ đọc thanh ghi Conversion chứ KHÔNG HỀ ghi lại thanh ghi Config để chuyển về Kênh 1\*\*. \*\*Hậu quả:\*\* Sau lần đọc Gas đầu tiên, ADC sẽ mãi mãi nằm ở \*\*Kênh 0\*\*. Khi hàm đọc Bụi chạy, nó nghĩ là nó đang đọc Kênh 1, nhưng thực tế nó đang đọc dữ liệu còn sót lại hoặc dữ liệu mới của \*\*Kênh 0 (Gas)\*\*. \\=\\> \*\*Kết quả Bụi PM2.5 hiển thị trên màn hình thực chất là giá trị của cảm biến Gas\\!\*\* \*\*Câu hỏi xoáy:\*\* > \*"Em khởi tạo chế độ Continuous cho cảm biến Bụi (Kênh 1). Nhưng ngay sau đó cảm biến Gas lại cấu hình ADC sang Kênh 0. Trong hàm đọc Bụi, tôi không thấy dòng code nào chuyển lại Kênh 1 cả. Vậy có phải em đang lấy giá trị Gas để hiển thị cho Bụi không?"\* ----- ### ĐIỂM CHẾT 2: SAI NGUYÊN LÝ LẤY MẪU BỤI (TIMING MISMATCH) \*\*Mức độ:\*\* Chí mạng (Cảm biến bụi sẽ luôn trả về 0 hoặc rác). \*\*Phân tích:\*\* \* \*\*Yêu cầu cảm biến GP2Y:\*\* Cần bật LED hồng ngoại, chờ \*\*0.28ms (280µs)\*\* rồi lấy mẫu điện áp \*\*ngay tại thời điểm đó\*\*. Độ rộng xung LED chỉ có 0.32ms. \* \*\*Thực tế ADS1115:\*\* Bạn đang dùng chế độ Continuous hoặc Single-shot với tốc độ \*\*128 SPS\*\* (Samples Per Second). Tức là mất khoảng \*\*7.8ms\*\* để ADC chuyển đổi xong 1 mẫu. \* \*\*Code của bạn:\*\* \`\`\`c DUST\_LED = 0; // Bật LED delay\_us(280); // Chờ 280us val = ADS1115\_ReadContinuous(); // Đọc giá trị ADC \`\`\` \* \*\*Vấn đề:\*\* Hàm \`ReadContinuous\` chỉ đọc giá trị \*đã chuyển đổi xong\* trong thanh ghi. Giá trị này là kết quả của quá trình tích hợp tín hiệu trong \*\*8ms trước đó\*\*. Lúc bạn bật LED và chờ 280µs, ADC \*\*không hề biết\*\* để bắt đầu lấy mẫu ngay lúc đó. Nó vẫn đang chạy theo nhịp 8ms của riêng nó. Vì xung LED (0.32ms) quá ngắn so với thời gian lấy mẫu của ADS1115 (8ms), xác suất để ADC "bắt" trúng lúc LED đang sáng là cực thấp. Đa phần thời gian nó sẽ đo lúc LED tắt. \*\*Hậu quả:\*\* Giá trị đo được sẽ cực nhỏ hoặc bằng 0, vì ADC đo trung bình của "bóng tối" chứ không đo được ánh sáng phản xạ từ bụi trong khoảnh khắc 280µs kia. \*\*Câu hỏi xoáy:\*\* > \*"Cảm biến bụi Sharp yêu cầu lấy mẫu chính xác tại thời điểm 0.28ms sau khi bật LED. Con ADS1115 của em tốc độ mẫu chỉ 128SPS (mỗi mẫu mất 8ms). Làm sao em dùng một cái thước đo chậm chạp (8ms) để đo một sự kiện siêu nhanh (0.3ms)? Code của em đang đọc giá trị 'lịch sử' chứ đâu phải giá trị tức thời lúc bật LED?"\* ----- ### PHƯƠNG ÁN ĐỐI PHÓ (CHỮA CHÁY) Đây là 2 lỗi rất khó sửa triệt để nếu không đổi phần cứng (ADC nội của vi điều khiển khác hoặc ADC tốc độ cao), nhưng bạn có thể trả lời khéo léo: \*\*Trả lời cho Điểm chết 1 (Xung đột Kênh):\*\* > \*"Dạ, đây là thiếu sót trong việc quản lý trạng thái ADC ạ. Đúng ra trong hàm \`GP2Y1014\_Read\`, em phải gọi lại hàm khởi tạo kênh 1 trước khi đọc. Nếu được sửa code, em sẽ chuyển hẳn sang chế độ \*\*Single-shot cho cả 2 cảm biến\*\* để đảm bảo mỗi lần đọc đều cấu hình lại kênh chính xác, tránh xung đột ạ."\* \*\*Trả lời cho Điểm chết 2 (Sai timing):\*\* > \*"Dạ thầy nhận xét rất đúng về mặt kỹ thuật ạ. ADS1115 là dòng ADC Delta-Sigma nên tốc độ phản hồi chậm, không tối ưu cho việc bắt xung hẹp như cảm biến Sharp. > Tuy nhiên, do 8051 không có ADC nội, và để tiết kiệm chi phí nên em tận dụng module này. Giải pháp 'chữa cháy' của em là chấp nhận sai số, coi giá trị đọc được là giá trị trung bình mức nền, và hiệu chỉnh bằng hệ số phần mềm (Calibration) để ra con số tương đối chấp nhận được cho đồ án môn học ạ."\* (Thú nhận là cách tốt nhất, vì lỗi này thuộc về sai lầm chọn linh kiện).